package blockchain

import (
	"bytes"
	"context"
	"crypto/sha256"
	"encoding/gob"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	pubsub "github.com/libp2p/go-libp2p-pubsub"
	bolt "go.etcd.io/bbolt"
)

type Block struct {
	Height     int           `json:"height"`
	TxData     []Transaction `json:"transaction_data"`
	Timestamps string        `json:"timestamps"`
	Nonce      int           `json:"nonce"`
	Hash       string        `json:"hash"`
	PrevHash   string        `json:"prev_hash"`
}

type Blockchain struct {
	Chain      []*Block
	Difficulty int // Mining Difficulty. In real blockchains, this is adjusted dynamically over time.
	Db         *bolt.DB
	mu         sync.Mutex
}

var bc *Blockchain

// NewBlockchain initializes a Blockchain with the given BoltDB instance.
// It loads existing blocks from the database and returns the Blockchain.
func NewBlockchain(db *bolt.DB) (*Blockchain, error) {
	bc := &Blockchain{
		Difficulty: 2,
		Db:         db,
	}
	err := bc.Load()

	return bc, err
}

// Load loads all blocks from the db
// Returns error if Db for blockchain is not initialised or if the transactions fails
func (bc *Blockchain) Load() error {
	bc.mu.Lock()
	defer bc.mu.Unlock()

	if bc.Db == nil {
		return errors.New("Cannot load blockchain. Blockchain is not initialised with a Db")
	}
	var blocks []*Block
	err := bc.Db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blockBucket))
		if b == nil {
			return errors.New("bucket not found")
		}

		// Search for latest block hash
		tip := b.Get([]byte("tip"))
		if tip == nil {
			return nil
		}

		hash := tip
		// Traverse blocks with prevHash in reverse direction
		for hash != nil && len(hash) > 0 {
			blockBytes := b.Get(hash)
			block, err := deserializeBlock(blockBytes)
			if err != nil {
				return err
			}
			blocks = append(blocks, &block)
			if block.PrevHash == "" {
				break
			}
			hash = []byte(block.PrevHash)
		}
		return nil
	})

	// Reverse the obtained block slice to get the correct order
	for i, j := 0, len(blocks)-1; i < j; i, j = i+1, j-1 {
		blocks[i], blocks[j] = blocks[j], blocks[i]
	}

	bc.Chain = append(bc.Chain, blocks...)

	return err
}

// AddBlock add the new block to the blockchain
func (bc *Blockchain) AddBlock(block *Block) error {
	bc.mu.Lock()
	defer bc.mu.Unlock()

	logger.Infof("Writing Block:[%s] to db\n", block.Hash)
	err := RetryN(func() error {
		err := bc.WriteBlock(block)
		return err
	}, 3, fmt.Sprintf("Error writing block:[%s] to db", block.Hash))

	// Add block to in-memory chain after successfull write of the block to the db to ensure consistency
	if err == nil {
		bc.Chain = append(bc.Chain, block)
	}

	return err
}

// WriteBlock writes the given block to the DB.
// Returns error if db operation fails.
func (bc *Blockchain) WriteBlock(block *Block) error {
	err := bc.Db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blockBucket))
		if b == nil {
			return errors.New("block bucket not found")
		}

		blockBytes, err := serializeBlock(*block)
		if err != nil {
			return err
		}

		if err = b.Put([]byte(block.Hash), blockBytes); err != nil {
			return err
		}

		if err = b.Put([]byte("tip"), []byte(block.Hash)); err != nil {
			return err
		}
		return nil
	})
	return err
}

func (bc *Blockchain) NewBlock() *Block {
	var blockHeight int
	var pvHash string
	var transactions []Transaction

	if len(bc.Chain) == 0 {
		blockHeight = 0
		pvHash = ""
	} else {
		blockHeight = bc.Chain[len(bc.Chain)-1].Height + 1
		pvHash = bc.Chain[len(bc.Chain)-1].Hash
	}

	if len(mempool.transactions) != 0 {
		tx := &Transaction{}
		for _, t := range mempool.transactions {
			tx = t
			break
		}
		transactions = append(transactions, GenerateCoinbaseTx(), *tx)
	} else {
		transactions = append(transactions, GenerateCoinbaseTx())
	}

	b := Block{
		Height:     blockHeight,
		TxData:     transactions,
		Timestamps: time.Now().String(),
		PrevHash:   pvHash,
	}
	return &b
}

func MineBlocks(ctx context.Context, bReceiver <-chan *Block, blockPublisher *pubsub.Topic) {
	for {
		block := bc.NewBlock()

		logger.Info("Mining for new block...")
	NonceFinder:
		for i := 0; ; i++ {
			block.Nonce = i
			hash := block.calculateHash()
			prefix := strings.Repeat("0", bc.Difficulty)

			if strings.HasPrefix(hash, prefix) {
				block.Hash = hash
				logger.Successf("Hell yeah!! Block:[%s] is mined\n", hash)

				if !block.isValid() {
					logger.Warn("Skipping to add block: Invalid block generated by miner")
					continue
				}

				for _, tx := range block.TxData {
					if !tx.IsCoinbase {
						mempool.RemoveTransaction(tx.TxID)
					}
				}

				err := bc.AddBlock(block)
				if err != nil {
					logger.Errorf("Error adding block: %v\n", err)
				} else {
					logger.Successf("Block:[%s] added", block.Hash)
				}

				utxoSet.Update()

				blockBytes, err := json.Marshal(block)
				if err != nil {
					logger.Errorf("Error marshaling block generated by miner: %v\n", err)
				}

				err = blockPublisher.Publish(ctx, blockBytes)
				if err != nil {
					logger.Errorf("Error publishing block: %v\n", err)
				} else {
					logger.Successf("Block:[%s] broadcasted successfully\n", block.Hash)
				}
				break NonceFinder
			}

			select {
			// In case a new block is received we check
			// if received blocks' index == current mining block index -> stop mining for the current block
			case receivedBlock := <-bReceiver:
				logger.Infof("Block is received %s", receivedBlock.Hash)
				if receivedBlock.Height == block.Height {
					break NonceFinder
				}
			default:
			}

			time.Sleep(time.Millisecond * 100) // Simulate delay in mining
		}

	}
}

func (b *Block) isValid() bool {
	if len(bc.Chain) > 0 {
		prevBlock := bc.Chain[len(bc.Chain)-1]
		if prevBlock.Height+1 != b.Height {
			logger.Error("Block validation failed: invalid block height")
			return false
		}
		if prevBlock.Hash != b.PrevHash {
			logger.Error("Block validation failed: previous block hash not matched")
			return false
		}
	}
	if !b.validateHash() {
		logger.Error("Block validation failed: invalid hash")
		return false
	}

	return true
}

func (b *Block) validateHash() bool {
	h := b.calculateHash()
	if h != b.Hash {
		return false
	}
	return true
}

func (b *Block) calculateHash() string {
	data := strconv.Itoa(b.Height) + TransactionsToString(b.TxData) + b.Timestamps + strconv.Itoa(b.Nonce) + b.PrevHash

	hash := sha256.Sum256([]byte(data))

	return hex.EncodeToString(hash[:])
}

func (bc *Blockchain) GetLatestBlockHeight() int {
	if len(bc.Chain) == 0 {
		return -1
	}
	blockHeight := bc.Chain[len(bc.Chain)-1].Height
	return blockHeight
}

func serializeBlock(b Block) ([]byte, error) {
	var buf bytes.Buffer
	err := gob.NewEncoder(&buf).Encode(b)
	return buf.Bytes(), err
}

func deserializeBlock(data []byte) (Block, error) {
	var b Block
	err := gob.NewDecoder(bytes.NewReader(data)).Decode(&b)
	return b, err
}
